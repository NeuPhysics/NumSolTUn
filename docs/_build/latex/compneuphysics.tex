%% Generated by Sphinx.
\def\sphinxdocclass{puthesis}
\documentclass[letterpaper,12pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional\else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}

\usepackage{geometry}
\usepackage{multirow}
\usepackage{eqparbox}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{2}



\title{Computational Methods Notes}
\date{Sep 13, 2017}
\release{0.0.1}
\author{Lei Ma}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}


This project is part of \sphinxhref{http://neutrino.xyz}{NeuPhysics} . The project \sphinxhref{http://docs.neutrino.xyz}{neutrino physics notes} is meant for the theoretical part of neutrino physics. As the research is going on, numerical method shows its importance. Hence we set up this project to take notes on the computational aspects of neutrino physics.
\begin{figure}[htbp]
\centering
\sphinxhref{http://creativecommons.org/licenses/by-nc-sa/3.0/us/}{\sphinxincludegraphics{{cc_byncsa}.png}}\end{figure}

Here is an index: \sphinxurl{genindex.html} .


\chapter{Introduction}
\label{\detokenize{intro::doc}}\label{\detokenize{intro:computational-neutrino-physics}}\label{\detokenize{intro:introduction}}
This project will demonstrate the power and misery of numerical method in neutrino physics.

Here are some words about programming language. Python is easy to begin with, but it is \sphinxhref{http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=python3\&lang2=gpp}{slow compared to C/C++}. So choose wisely about the language we use.


\chapter{Preliminary}
\label{\detokenize{preliminary/index::doc}}\label{\detokenize{preliminary/index:preliminary}}

\section{Numerical Basics}
\label{\detokenize{preliminary/numerical-basics::doc}}\label{\detokenize{preliminary/numerical-basics:numerical-basics}}

\subsection{Precision, Error, etc}
\label{\detokenize{preliminary/numerical-basics:precision-error-etc}}
Floating-point representation is
\begin{equation*}
\begin{split}S\times M \times b^{E-e},\end{split}
\end{equation*}
where S is the sign, M is the mantissa, E is the integer exponent, b is the base and e is the bias of the exponent.

\sphinxstylestrong{Round off} is the bias from the machine accuracy and it accumulates.

\sphinxstylestrong{Truncation error} is the difference between  the true answer and teh answer obtained. The reason for this is that we are doing numerical calculations by descretizing the functions. This error is the discrepancy on a ideal computer that n round off is present.

As the round off error gets magnified and finally swamp the useful answer in the calculation, the method is unstable. An algrimth like this can work on a ideal computer but not a practical one.


\section{Data Structure}
\label{\detokenize{preliminary/data-structure::doc}}\label{\detokenize{preliminary/data-structure:id1}}\label{\detokenize{preliminary/data-structure:data-structure}}
Dealing with data structure is like dealing with your cloth. Some people simply randomly drop their cloth somewhere without thinking. But it takes time to retrieve a specific T-shirt. Some poeple spend some time fold and arrange their cloth. However that make it easy to find a specific T-shirt. It's always a balance between the computation time and the coding time.


\subsection{Some Useful Data Structures}
\label{\detokenize{preliminary/data-structure:some-useful-data-structures}}

\subsubsection{Array}
\label{\detokenize{preliminary/data-structure:array}}
Array is accessed with indices.


\subsubsection{Linked List}
\label{\detokenize{preliminary/data-structure:linked-list}}
The first element is \sphinxstylestrong{head} while the last element is \sphinxstylestrong{tail}.

Elements can be linked through two different ways, Signly Linked List or Doubly Linked List.

Each node of the singly linked list is assigned two fields, the first field is the value of the node, which stores the information we need, the second field is the link to the next node.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Singly-linked-list}.svg}
\caption{Singly linked list illustration from \sphinxhref{https://en.wikipedia.org/wiki/Linked\_list}{Wikipedia}.}\label{\detokenize{preliminary/data-structure:id2}}\end{figure}

Suppose we are solving the \sphinxhref{https://en.wikipedia.org/wiki/Josephus\_problem}{Josephus problem}. Linked list is good for deletion, however it is computation consuming when it comes to the counting. On the other hand, array structure is good for determining which on to delete, but the deletion involves rearrangement of index the array which is time consuming.


\subsubsection{Stack}
\label{\detokenize{preliminary/data-structure:stack}}
Stack is good for adding new items and removing the most recent-added item. (\sphinxhref{https://enkipro.com//insight/58f77be3d2d15f373906a905}{on Enki})

Stack data structure is Last in First out, aka LIFO. There are only two ways to change the stack, which are adding item to the stack and removing the item at the top.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Lifo_stack}.png}
\caption{Stack from Wikipedia}\label{\detokenize{preliminary/data-structure:id3}}\end{figure}


\subsubsection{Queue}
\label{\detokenize{preliminary/data-structure:queue}}
Queue is First in First out, aka FIFO. The name Queue explains itself quite well. In a line of queue, the first one in the line would be the first one served and removed from the queue. To add into the queue, we have the put the new guy at the end of the queue.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{Data_Queue}.svg}
\caption{Queue from Wikipedia}\label{\detokenize{preliminary/data-structure:id4}}\end{figure}


\subsection{References and Notes}
\label{\detokenize{preliminary/data-structure:references-and-notes}}\begin{enumerate}
\item {} 
I learned some of these in enki app.

\end{enumerate}


\chapter{Python Basics}
\label{\detokenize{python/index::doc}}\label{\detokenize{python/index:python-basics}}

\section{Python Basics}
\label{\detokenize{python/python-basics::doc}}\label{\detokenize{python/python-basics:python-basics}}

\subsection{Numbers, Arithmetics}
\label{\detokenize{python/python-basics:numbers-arithmetics}}
Two types of numbers exisit,
\begin{enumerate}
\item {} 
int

\item {} 
float, 15 digits, other digits are float error

\end{enumerate}

Arithmetic
\begin{quote}

print 1.0/3
\end{quote}

will give us float numbers, while
\begin{quote}

print 1/3
\end{quote}

will only give us int.


\subsection{Variables, Functions, Conditions}
\label{\detokenize{python/python-basics:variables-functions-conditions}}
Variable name should start with either a letter or a underscore.

Variables defined inside a function is local and there is no way to find it or use it outside the function. It is even possible to reuse an already used global variable inside a function.
\begin{quote}

\# num1 is a global variable

num1 = 1
print num1

\# num2 is a local variable
\begin{description}
\item[{def fun():}] \leavevmode
num1 = 2
num2 = num1 + 1
print num2

\end{description}

fun()
\end{quote}

where the first line will give us 1 but the second output is 3. (Code from Coursera course interactivepython-005/lecture/15.)

If we want to use the global variable and change the value of it, the program can be like this,
\begin{quote}

num = 4
\begin{description}
\item[{def fun1():}] \leavevmode
global num
num = 5

\item[{def fun2():}] \leavevmode
global num
num = 6

\end{description}

\# note that num changes after each call with no obvious explanation
print num
fun1()
print num
fun2()
print num
\end{quote}

from Coursera course interactivepython-005/lecture/15.

Start a function by a comment says what the function does.
\begin{quote}
\begin{description}
\item[{def triangle\_area(base, height):     \# header - ends in colon}] \leavevmode
area = (1.0 / 2) * base * height \# body - all of body is indented
return area                      \# body - return outputs value

\end{description}
\end{quote}

from Coursera course interactivepython-005/lecture/8.

\sphinxquotedblright{}:\sphinxquotedblright{}\sphinxquotedblright{} indicates that a block code is following, which should be indented.
\begin{quote}

\# will return True if a year is a leap year on Mars
def is\_leap\_year(year):
\begin{quote}
\begin{description}
\item[{if year \% 3000 == 0:}] \leavevmode
return False

\item[{elif year \% 1000 == 0:}] \leavevmode
return True

\item[{elif year \% 100 == 0:}] \leavevmode
return False

\item[{elif (year \% 2 == 0) and (year \% 10 == 0):}] \leavevmode
return True

\item[{else:}] \leavevmode
return False

\end{description}
\end{quote}
\end{quote}


\subsection{Zen Code}
\label{\detokenize{python/python-basics:zen-code}}\begin{enumerate}
\item {} 
\sphinxurl{https://www.python.org/doc/essays/list2str/}

\item {} 
Try \sphinxtitleref{filter()}, \sphinxtitleref{map()}, \sphinxtitleref{reduce()}.

\end{enumerate}


\section{Performance Issue in Python}
\label{\detokenize{python/performance::doc}}\label{\detokenize{python/performance:performance-issue-in-python}}

\subsection{References and Notes}
\label{\detokenize{python/performance:references-and-notes}}\begin{enumerate}
\item {} 
I noticed a very interesting blog: \sphinxhref{https://www.ibm.com/developerworks/community/blogs/jfp?lang=en}{IT Best Kept Secret Is Optimization}.

\item {} 
\sphinxtitleref{How To Make Python Run As Fast As Julia \textless{}https://www.ibm.com/developerworks/community/blogs/jfp/entry/Python\_Meets\_Julia\_Micro\_Performance?lang=en\textgreater{}}.

\end{enumerate}


\chapter{Using Scipy}
\label{\detokenize{scipy/index::doc}}\label{\detokenize{scipy/index:using-scipy}}

\section{Scipy Basics}
\label{\detokenize{scipy/scipy-basics::doc}}\label{\detokenize{scipy/scipy-basics:scipy-basics}}

\chapter{The C++ Language}
\label{\detokenize{cpp/index::doc}}\label{\detokenize{cpp/index:the-c-language}}

\section{C++ Basics}
\label{\detokenize{cpp/basics::doc}}\label{\detokenize{cpp/basics:c-basics}}

\subsection{Make it Work}
\label{\detokenize{cpp/basics:make-it-work}}
Apart from the tranditional way of running C++ code, Jupyter notebook has a clingkernel that make it possibel to run C++ in a Jupyter notebook. Here is the post: \sphinxhref{http://johntfoster.github.io/posts/interactive-c\%2B\%2B-for-hpc.html}{Interactive C++ for HPC}.


\subsection{Concepts}
\label{\detokenize{cpp/basics:concepts}}\begin{enumerate}
\item {} 
Namespace

\item {} 
Operators: assignment operators (=,+=,-=,*=,/=,\%=), increment/decrement operator (++x,x++,--x,x--), relational operators (\textgreater{},\textless{},\textgreater{}=,\textless{}=,==,!=), logicl operators (\&\&,\textbar{}\textbar{},!), left shift (\textless{}\textless{}), extration operator (\textgreater{}\textgreater{}, or right shift), understand the operator precedence

\item {} 
Variables: variable name starts with underscore or latin letters, Pascal case (PascalCase), Camel case (pascalCase)

\item {} 
if/else and Loops: if (condition is true )\{ then something \}

\item {} 
Data Types: string (double quote), character (char, 1 byte ASCII character, using single quote), float (4 bytes, always signed), double (8 bytes, always signed), long double (8 or 16 bytes, always signed), singed or unsigned short or long int (signed long int, unsigned int)

\item {} 
Pointers: ampersand (\&) accesses the address, pointer is variable thus needs to be declared using asterisk ( * ), can be declared to be int or double or float or char (int *pt; int* pt; int * pt; )

\item {} 
Functions: overload, recursion

\item {} 
Class: identity, atrributes, method/behavior, access specifiers (private or public or protected, by default it is set to private), instantiation of object (creating object), constructor, destructor, encapsulation, scope resolution operator (TheClassYouNeed::somefunction() ), selection operator (dot member selection . used to access members, or arrow member selection -\textgreater{}, used to access members with pointer), composition (assemble a larger class using small classes), friend function (friend void aFunc(); to access private members), this pointer (this -\textgreater{} var, ({\color{red}\bfseries{}*}this).var ), operator overloading (using operator key), inheritance (Base class, Derived class), polymorphism, virtual function (using virtual key, useful in polymorphism, pure virtual function is virtual void attack() = 0;)

\item {} 
Function Templates:

\item {} 
Exceptions: try, catch, throw

\end{enumerate}


\subsubsection{Clarifications}
\label{\detokenize{cpp/basics:clarifications}}
\begin{sphinxadmonition}{note}{Increment and Decrement Operator}

Increment/decrement operator has a very high precedence if applied from the left.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{;}
\PYG{n}{y} \PYG{o}{=} \PYG{o}{+}\PYG{o}{+}\PYG{n}{x}\PYG{p}{;}
\PYG{c+c1}{// prefix: x=3, y=3; ++ is calculated first then assigned to y;}

\PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{3}\PYG{p}{;}
\PYG{n}{b} \PYG{o}{=} \PYG{n}{a}\PYG{o}{+}\PYG{o}{+}\PYG{p}{;}
\PYG{c+c1}{// postfix: a = 4, b= 3; ++ is calculated after the asignment}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Omitted Curly Braces in if statement}

Omitted curly braces in if/else statement works if it has only one statement. If you like Python, this is an excellent practice.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k+kt}{int} \PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{j}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{;}

   \PYG{k}{if} \PYG{p}{(}\PYG{n}{i} \PYG{o}{\PYGZgt{}} \PYG{n}{j}\PYG{p}{)}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{i\PYGZgt{}j}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
   \PYG{k}{else}
      \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{j\PYGZlt{}=i}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}

   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Comparing Two Numbers}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{a} \PYG{o}{\PYGZlt{}} \PYG{n}{b} \PYG{o}{?} \PYG{n+nl}{a} \PYG{p}{:} \PYG{n}{b}
\PYG{c+c1}{// output a if express a\PYGZlt{}b is true otherwise output b;}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{default statement for switch}

default statement for swtich must be at the end of the statements of switch.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{age} \PYG{o}{=} \PYG{l+m+mi}{18}\PYG{p}{;}
\PYG{k}{switch} \PYG{p}{(}\PYG{n}{age}\PYG{p}{)} \PYG{p}{\PYGZob{}}
  \PYG{k}{case} \PYG{l+m+mi}{1}\PYG{o}{:}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Baby}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{break}\PYG{p}{;}
  \PYG{k}{case} \PYG{l+m+mi}{6}\PYG{o}{:}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Boy}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
    \PYG{k}{break}\PYG{p}{;}
  \PYG{k}{default}\PYG{o}{:}
    \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Oh yeah?}\PYG{l+s}{\PYGZdq{}}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{strings and string library}

\textless{}string\textgreater{} library is necessay for string data type but it is also included in other libs such as \textless{}iostream\textgreater{}.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Tips about Pointers}

To understand the ampersand and asterisk operators, we look at the following example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{z}\PYG{o}{=}\PYG{l+m+mi}{42}\PYG{p}{;}
\PYG{k+kt}{int}  \PYG{o}{*}\PYG{n}{ptrx}\PYG{p}{,} \PYG{o}{*}\PYG{n}{ptry}\PYG{p}{,} \PYG{o}{*}\PYG{n}{ptrz}\PYG{p}{;}
\PYG{n}{ptrx} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{x}\PYG{p}{;}
\PYG{n}{ptry} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{y}\PYG{p}{;}
\PYG{n}{ptrz} \PYG{o}{=} \PYG{o}{\PYGZam{}}\PYG{n}{z}\PYG{p}{;}

\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{z} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{// 42; since it\PYGZsq{}s a variable}

\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ptrz} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{// 0x28ff18; only for this run;  ptr is the memory address}

\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{ptrz} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{// 42; since dereference operator (*) is dereferencing it}

\PYG{n}{z} \PYG{o}{=} \PYG{n}{z} \PYG{o}{+} \PYG{n}{x}\PYG{p}{;}
\PYG{n}{z} \PYG{o}{=} \PYG{o}{*}\PYG{n}{ptrz} \PYG{o}{+} \PYG{n}{x}\PYG{p}{;}
\PYG{o}{*}\PYG{n}{ptrz} \PYG{o}{=} \PYG{o}{*}\PYG{n}{ptrz} \PYG{o}{+} \PYG{n}{x}\PYG{p}{;}
\PYG{c+c1}{// all three are equivalent to z = z + x}

\PYG{o}{*}\PYG{n}{ptrz} \PYG{o}{=} \PYG{o}{*}\PYG{n}{ptrx} \PYG{o}{+} \PYG{o}{*}\PYG{n}{ptry}\PYG{p}{;}
\PYG{c+c1}{// equivalent to z = x + y}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Function Overloading}

Function overloading can be done by varying parameter types or number of parameters but not by change return type.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Recursion in C++}

The best example for recursion is to calculate factorials.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{n+nf}{factorial}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{n}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{if} \PYG{p}{(}\PYG{n}{n}\PYG{o}{=}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{l+m+mi}{1}\PYG{p}{;}
      \PYG{c+c1}{// this is also called the base case;}
   \PYG{p}{\PYGZcb{}}
   \PYG{k}{else} \PYG{p}{\PYGZob{}}
      \PYG{k}{return} \PYG{n}{n} \PYG{o}{*} \PYG{n}{factorial}\PYG{p}{(}\PYG{n}{n}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
      \PYG{c+c1}{// recursion until the argument passed to factorial becomes 1 then it returns the base case;}
   \PYG{p}{\PYGZcb{}}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Passing Arguments to Function by Value or Reference}

Passing by value is what we usally do. The function essentially copies the value of the parameters. Thus any change of the parameters inside function doesn't change the original passed variables.

Passing by reference is very different. It passes the pointer to the function and thus any change to the parameters will change the originally defiend variables.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{addOne}\PYG{p}{(}\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{ptr}\PYG{p}{)} \PYG{p}{\PYGZob{}}
   \PYG{k}{return} \PYG{o}{*}\PYG{n}{ptr} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// defined to take pointers as parameters;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

   \PYG{k+kt}{int} \PYG{n}{a} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{;}
   \PYG{c+c1}{// declare a variable which has a value 42;}

   \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a is }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
   \PYG{c+c1}{// output the value of a before calling the function;}

   \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{addOne(a)}\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{addOne}\PYG{p}{(}\PYG{o}{\PYGZam{}}\PYG{n}{a}\PYG{p}{)} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
   \PYG{c+c1}{// the function return;}

   \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{a becomes }\PYG{l+s}{\PYGZdq{}} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{a} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
   \PYG{c+c1}{// since I used += in the function, the value of the parameters changed;}

   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Defining Class}

When define class a semicolon is always attached to the end of it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{class} \PYG{n+nc}{TheClassYouNeed} \PYG{p}{\PYGZob{}}

   \PYG{c+c1}{//blablabla}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}
\PYG{c+c1}{// the semicolon}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Constructor in Class}

When we need to initialize some variables in the class, constructor is helpful.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZlt{}iostream\PYGZgt{}}
\PYG{k}{using} \PYG{k}{namespace} \PYG{n}{std}\PYG{p}{;}

\PYG{k}{class} \PYG{n+nc}{TheClassYouNeed} \PYG{p}{\PYGZob{}}

      \PYG{k}{public}\PYG{o}{:}
         \PYG{n}{TheClassYouNeed}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{setWeight}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}

         \PYG{k+kt}{void} \PYG{n}{setWeight}\PYG{p}{(}\PYG{k+kt}{int} \PYG{n}{x}\PYG{p}{)} \PYG{p}{\PYGZob{}}
            \PYG{n}{weight} \PYG{o}{=} \PYG{n}{x}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}

         \PYG{k+kt}{int} \PYG{n}{getWeight}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
             \PYG{k}{return} \PYG{n}{weight}\PYG{p}{;}
         \PYG{p}{\PYGZcb{}}


      \PYG{k}{private}\PYG{o}{:}
         \PYG{k+kt}{int} \PYG{n}{weight}\PYG{p}{;}

\PYG{p}{\PYGZcb{}}\PYG{p}{;}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

   \PYG{n}{TheClassYouNeed} \PYG{n}{cs1}\PYG{p}{(}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{p}{;}
   \PYG{c+c1}{// constructor function will take the number 42 and pass it to weight;}

   \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{cs1}\PYG{p}{.}\PYG{n}{getWeight} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
   \PYG{c+c1}{// output the weight of object cs1;}

   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Two Files to Write a New Class}

We usually write class seperately in different classes. In this case we need to create two files, TheClassYouNeed.h and TheClassYouNeed.cpp.

In .h file we define the header.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{ifndef THECLASSYOUNEED\PYGZus{}H }\PYG{c+c1}{// \PYGZsh{}ifndef = if not defined; prevents from defining twice;}
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{define THECLASSYOUNEED\PYGZus{}H }\PYG{c+c1}{// then we define this}

\PYG{c+c1}{// the declarations of class}

\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{endif}
\end{sphinxVerbatim}

In .h file we declare everything while in .cpp we define the constructor/desctructor and functions/methods/behaviors.

When creating object using the class in the main function, we need to

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cp}{\PYGZsh{}}\PYG{c+cp}{include} \PYG{c+cpf}{\PYGZdq{}TheClassYouNeed.h\PYGZdq{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Constants and Constant Objects}

Constant variables have to be initialized on creation.

Constant objects should also be initialized using constructor. So the class has to have a constructor in it even without any parameters. Constant objects can NOT call non-constant functions, thus the methods are defined to be constant functions.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/* in the header file of the class */}

\PYG{c+c1}{// bla bla}
\PYG{k+kt}{void} \PYG{n+nf}{yourFunctionHere}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const}\PYG{p}{;}
\PYG{c+c1}{// bla bla}

\PYG{c+cm}{/* in the source file of the class */}

\PYG{c+c1}{// bla bla}
\PYG{k+kt}{void} \PYG{n}{TheClassYouNeed}\PYG{o}{:}\PYG{o}{:}\PYG{n}{yourFunctionHere}\PYG{p}{(}\PYG{p}{)} \PYG{k}{const} \PYG{p}{\PYGZob{}}
   \PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{Hello}\PYG{l+s}{\PYGZdq{}}\PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}}\PYG{n}{endl}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}
\PYG{c+c1}{// bla bla}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Initializaing Constant Variables in Class}

Have to use \sphinxstylestrong{member initializers} instead of the usual way.

But friend function is \sphinxstylestrong{not} a member of the class.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Passing Object to Function}

Need to pass the reference of the object to the function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{yourFunction}\PYG{p}{(}\PYG{n}{TheClassYouNeed} \PYG{o}{\PYGZam{}}\PYG{n}{anObject}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\PYG{c+c1}{// bla bla}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Derived Class Does Not Inherit All}

Constructors/destructors, overloaded operators and friend functions are not inherited from base class.

Private members can not be accessed from derived class but \sphinxstylestrong{protected} members can be.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Pure Virtual Functions in Polymorphism}

When we use a pure virtual function in base class, the derived class must override it.

Base class with pure virtual function can \sphinxstylestrong{NOT} be used to create objects. Thus these classes are called \sphinxstylestrong{abstract classes}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{virtual} \PYG{k+kt}{void} \PYG{n+nf}{attack}\PYG{p}{(}\PYG{p}{)} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{c+c1}{//this is a pure virtual function, which must be overrided;}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsubsection{Dynamic Memory}
\label{\detokenize{cpp/basics:dynamic-memory}}
There are two basic concepts of memory in C++, the stack and the heap. Declared variables in all the functions used in a program use memory from stack while the heap is some pool of memory ready for dynamical allocation.

The stack memory is will be released when the function return at the last step. It is also FILO, aka first in last out.

To access the heap, we use the new operator.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{ptr} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{;}
\PYG{c+c1}{// Allocate the memory for an integer on the heap; meanwhile returns the address for future use;}
\PYG{c+c1}{// The memory can be accessed globally;}
\PYG{c+c1}{// Needs to be freed later;}
\PYG{c+c1}{// Can be resized using realloc();}
\PYG{c+c1}{// can be deleted using delete ptr;}

\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ptr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{// the address of the allocated memory}

\PYG{o}{*}\PYG{n}{ptr} \PYG{o}{=} \PYG{l+m+mi}{42}\PYG{p}{;}
\PYG{c+c1}{// assign values to the memory}

\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{ptr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{// 42; output the values at the memory}

\PYG{k}{delete} \PYG{n}{ptr}\PYG{p}{;}
\PYG{c+c1}{// delete the value at the memory but the ptr is still there since it is stored in the stack memory;}
\end{sphinxVerbatim}

\begin{sphinxadmonition}{note}{NULL}

Assign a ponter NULL when defining it is a good habbit.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{int} \PYG{o}{*}\PYG{n}{ptr} \PYG{o}{=} \PYG{n+nb}{NULL}\PYG{p}{;}

\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{o}{*}\PYG{n}{ptr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{n}{cout} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{ptr} \PYG{o}{\PYGZlt{}}\PYG{o}{\PYGZlt{}} \PYG{n}{endl}\PYG{p}{;}
\PYG{c+c1}{// none of them outputs anything}

\PYG{n}{ptr} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{int}\PYG{p}{[}\PYG{l+m+mi}{42}\PYG{p}{]}\PYG{p}{;}
\PYG{c+c1}{// allocate memory for an array of length 42;}

\PYG{k}{delete} \PYG{p}{[}\PYG{p}{]} \PYG{n}{ptr}\PYG{p}{;}
\PYG{c+c1}{// delete the array that the pointer ptr is associated with;}
\PYG{c+c1}{// [] means delete the array}
\end{sphinxVerbatim}

Functions should be declared in the file that calls the function if it's defined in another file. The declaration of function can be seperate from the definition of the function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{void} \PYG{n+nf}{goldHeart}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\PYG{c+c1}{// this is the declaration of the function; notice we have not defined it}

\PYG{k+kt}{int} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}

   \PYG{n}{goldHeart}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}

   \PYG{k}{return} \PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void} \PYG{n+nf}{goldHeart}\PYG{p}{(}\PYG{p}{)} \PYG{p}{\PYGZob{}}
\PYG{c+c1}{// here is the definition of the function;}
\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Memory}
\label{\detokenize{cpp/basics:memory}}
Referring to {\hyperref[\detokenize{preliminary/data-structure:data-structure}]{\sphinxcrossref{\DUrole{std,std-ref}{Data Structure}}}},

Allocate memory for two dimensional array

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kt}{double} \PYG{p}{(}\PYG{o}{*}\PYG{n}{a}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]} \PYG{o}{=} \PYG{k}{new} \PYG{k+kt}{double}\PYG{p}{[}\PYG{l+m+mi}{5000}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{;}
\end{sphinxVerbatim}


\section{Numerical}
\label{\detokenize{cpp/numerical::doc}}\label{\detokenize{cpp/numerical:numerical}}

\subsection{Modularize}
\label{\detokenize{cpp/numerical:modularize}}\begin{enumerate}
\item {} 
Seperate physics from numerical stuff.

\end{enumerate}


\subsection{Speed}
\label{\detokenize{cpp/numerical:speed}}\begin{enumerate}
\item {} 
\sphinxtitleref{vectors} are convinient but slow. \sphinxhref{http://en.cppreference.com/w/cpp/container/vector}{Ref}

\item {} 
Do not copy arrays if not necessary. The example would be for a function return. Most of the times, we can pass pointer of array to the function and update the array itself without copying anything and no return is needed at all.

\item {} 
inline function.

\item {} 
Use \sphinxtitleref{namespace} instead of class if no data structure is stored in it.

\end{enumerate}


\section{Manipulating Matrices in C++}
\label{\detokenize{cpp/manipulating-matrices::doc}}\label{\detokenize{cpp/manipulating-matrices:manipulating-matrices-in-c}}

\chapter{Finite Difference Method}
\label{\detokenize{finite-difference/index::doc}}\label{\detokenize{finite-difference/index:finite-difference-method}}

\section{Ordinary Differential Equations}
\label{\detokenize{finite-difference/ode/index::doc}}\label{\detokenize{finite-difference/ode/index:ordinary-differential-equations}}
For a first order differentiation \(\frac{\partial f}{\partial t}\), we might have many finite differencing methods.
\begin{enumerate}
\item {} 
Forward Euler: \((f_{i+1} - f_i)/\Delta t\)

\end{enumerate}


\subsection{Euler Method}
\label{\detokenize{finite-difference/ode/euler::doc}}\label{\detokenize{finite-difference/ode/euler:euler-method}}
\index{Euler Method}
For linear first ODE,
\begin{equation*}
\begin{split}\frac{dy}{dx} = f(x, y),\end{split}
\end{equation*}
we can discretize the equation using a step size \(\delta x \cdot\) so that the differential equation becomes
\begin{equation*}
\begin{split}\frac{y_{n+1} - y_n }{ \delta x } = f(x_n, y_n),\end{split}
\end{equation*}
which is also written as
\phantomsection\label{\detokenize{finite-difference/ode/euler:equation-euler-method-discretized-form-y-n-plus-1}}\begin{equation}\label{equation:finite-difference/ode/euler:euler-method-discretized-form-y-n-plus-1}
\begin{split}y_{n+1} = y_n + \delta x \cdot  f(x_n, y_n).\end{split}
\end{equation}
This is also called \sphinxstylestrong{forward Euler} differencing. It is first order accurate in \(\Delta t\).

Generally speaking, a simple iteraction will do the work.


\subsection{Adams' Method}
\label{\detokenize{finite-difference/ode/adams::doc}}\label{\detokenize{finite-difference/ode/adams:adams-method}}
\index{Adams' Method}
\begin{sphinxadmonition}{note}{Taylor Expansion of Functions}

Suppose we have a function \(f(x)\), Taylor expansion arround a point \(x_0\) is
\begin{equation*}
\begin{split}f(x) = f(x_0) + f'(x_0) (x - x_0) + \cdots\end{split}
\end{equation*}
This is also named Maclaurin series.
\end{sphinxadmonition}

For linear first ODE,
\begin{equation*}
\begin{split}\frac{dy}{dx} = f(x, y),\end{split}
\end{equation*}
This equation can always be written as a integral form
\begin{equation*}
\begin{split}y(x_{n+1}) - y(x_n) = \int_{x_n}^{x_{n+1}} f(x,y) dx,\end{split}
\end{equation*}
which is basically a very general idea of how to numerically solve such an equation, as long as we can solve the integral efficiently and accurately. In other words, we are dealing with
\begin{equation*}
\begin{split}y(x_{n+1}) =  y(x_n) + \int_{x_n}^{x_{n+1}} f(x,y) dx.\end{split}
\end{equation*}
The problem is how exactly do we calculate the integral or the iteraction. Two methods are proposed as explicit method (\index{Adams-Bashforth Method}Adams-Bashforth Method) and implicit method (\index{Adams-Moulton Method}Adams-Moulton Method).

What can be done is to Taylor expand the integrand. At first order of \(f(x,y)\), we would have
\begin{equation*}
\begin{split}y(x_{n+1}) = y(x_n) + \int_{x_n}^{x_{n+1}} f(x_{n},y(x_n)) dx =  y(x_n) +(x_{n+1}- x_n) f(x_{n},y(x_n)) ,\end{split}
\end{equation*}
which is the Euler method. For simplicity step size is defined as
\phantomsection\label{\detokenize{finite-difference/ode/adams:equation-adams-method-step-size-def}}\begin{equation}\label{equation:finite-difference/ode/adams:adams-method-step-size-def}
\begin{split}\delta x = x_{n+1}- x_n.\end{split}
\end{equation}
Also to simplify the notation, we introduce the notation
\begin{equation*}
\begin{split}y_n = y(x_n).\end{split}
\end{equation*}
For second order, we have at least two different methods to approximate the integral.

\index{Adams-Bashforth Method}
\index{Explicit Adams Method}\begin{itemize}
\item {} 
Adams-Bashforth method is to approximate the integral using
\begin{quote}
\begin{equation*}
\begin{split}\int_{x_n}^{x_{n+1}} f(x,y) dx \sim \frac{1}{2} ( 3 f( x_n - f( x_{n-1}, y_{n-1} ) , y_n) ) \delta x\end{split}
\end{equation*}
where we used the definition of step size \eqref{equation:finite-difference/ode/adams:adams-method-step-size-def}.
\end{quote}

\end{itemize}

\index{Adams-Moulton Method}
\index{Implicit Adams Method}\begin{itemize}
\item {} 
Adams-Moulton method uses trapezoidal rule, which approximates the integral as
\begin{quote}
\begin{equation*}
\begin{split}\int_{x_n}^{x_{n+1}} f(x,y) dx \sim \frac{1}{2} f( x_{n+1} + f(x_n, y_n) , y_{n+1} ),\end{split}
\end{equation*}
which is similar to backward Euler method but of second order.
\end{quote}

\end{itemize}

In fact the AB and AM methods to the first order are
\begin{itemize}
\item {} 
Adams-Bashforth Method First Order = Forward Euler Method;

\item {} 
Adams-Moulton Method First Order = Backward Euler Method.

\end{itemize}

\begin{sphinxadmonition}{note}{scipy.odeint}

\sphinxtitleref{scipy.odeint} uses \sphinxtitleref{adams} for nonstiff equations, where even higher order are used. The return infodictionary entry \sphinxtitleref{nqu} shows the orders for each successful step.
\end{sphinxadmonition}


\subsubsection{Refs \& Notes}
\label{\detokenize{finite-difference/ode/adams:refs-notes}}\begin{enumerate}
\item {} 
\sphinxhref{http://web.mit.edu/10.001/Web/Course\_Notes/Differential\_Equations\_Notes/node6.html}{Adams Methods @ MIT Web Course}

\item {} 
\sphinxhref{http://mathworld.wolfram.com/AdamsMethod.html}{Adams' Method @ Wolfram MathWorld}

\end{enumerate}


\section{Partial Differential Equation}
\label{\detokenize{finite-difference/pde/index::doc}}\label{\detokenize{finite-difference/pde/index:partial-differential-equation}}

\subsection{Forward Time Centered Space}
\label{\detokenize{finite-difference/pde/index:forward-time-centered-space}}
For \(\frac{d f}{d t} = - v \frac{ d f }{ dx }\), we write down the finite difference form \phantomsection\label{\detokenize{finite-difference/pde/index:id1}}{\hyperref[\detokenize{finite-difference/pde/index:numericalrecipes}]{\sphinxcrossref{{[}NumericalRecipes{]}}}}
\begin{equation*}
\begin{split}\frac{f(t_{n+1}, x_i ) - f(t_n, x_i)}{ \Delta t } = - v \frac{ f(t_n, x_{i+1}) - f(t_n, x_{i-1}) }{ 2\Delta x }.\end{split}
\end{equation*}
FTCS is an explicit method and is not stable.


\subsection{Lax Method}
\label{\detokenize{finite-difference/pde/index:lax-method}}
Change the term \(f(t_n, x_i)\) in FTCS to \(( f(t_n, x_{i+1}) + f(t_n, x_{i-1}) )/2\)  \phantomsection\label{\detokenize{finite-difference/pde/index:id2}}{\hyperref[\detokenize{finite-difference/pde/index:numericalrecipes}]{\sphinxcrossref{{[}NumericalRecipes{]}}}}.

Stability condition is
\begin{equation*}
\begin{split}\frac{ \lvert v \rvert \Delta t }{ \Delta x } \leq 1,\end{split}
\end{equation*}
which is the Courant-Fridriches-Lewy stability criterion.


\subsection{Staggered Leapfrog}
\label{\detokenize{finite-difference/pde/index:staggered-leapfrog}}\begin{equation*}
\begin{split}\frac{f(t_{n+1}, x_i) - f(t_{n-1}, x_i)}{2 \Delta t} = -v \frac{ f(t_n, x_{i+1} ) - f(t_n, x_{i-1} ) }{ 2\Delta x}\end{split}
\end{equation*}
It's kind of a Centered Space Centered Time method.


\subsection{Two-Step Lax-Wendroff Scheme}
\label{\detokenize{finite-difference/pde/index:two-step-lax-wendroff-scheme}}

\subsection{Fully Implicit}
\label{\detokenize{finite-difference/pde/index:fully-implicit}}\begin{equation*}
\begin{split}\frac{ f( t_{n+1} , x_i ) - f( t_{n} , x_i ) }{ \Delta t } = - v \frac{ f(t_{n+1}, x_{i+1}) - f(t_{n+1}, x_{i-1}) }{ 2\Delta x }.\end{split}
\end{equation*}
It is called implicity because we can not simply iterate over the formula to get the solutions as like for the explicit method.


\subsection{Crank-Nicholson}
\label{\detokenize{finite-difference/pde/index:crank-nicholson}}
Crank-Nicholson is a average of the explicit and fully implicit method.
\begin{equation*}
\begin{split}\frac{ f( t_{n+1} , x_i ) - f( t_{n} , x_i ) }{ \Delta t } = - \frac{v}{2} \frac{ \left(f(t_{n+1}, x_{i+1}) - f(t_{n+1}, x_{i-1}) \right) + \left( f(t_{n}, x_{i+1}) - f(t_{n}, x_{i-1}) \right)}{ 2\Delta x }.\end{split}
\end{equation*}

\subsection{References and Notes}
\label{\detokenize{finite-difference/pde/index:references-and-notes}}

\section{Optimize}
\label{\detokenize{finite-difference/optimize::doc}}\label{\detokenize{finite-difference/optimize:optimize}}

\subsection{SLSQ}
\label{\detokenize{finite-difference/optimize:slsq}}
SLSQ, sequential least squares, uses an iteration formula of the least squares to optimize a function.


\section{Genetic Algorimth}
\label{\detokenize{finite-difference/gene::doc}}\label{\detokenize{finite-difference/gene:genetic-algorimth}}

\chapter{Numerical Integral}
\label{\detokenize{integral/index::doc}}\label{\detokenize{integral/index:numerical-integral}}

\section{Numerical Integral Methods}
\label{\detokenize{integral/methods::doc}}\label{\detokenize{integral/methods:numerical-integral-methods}}

\subsection{List of Methods and Highlight}
\label{\detokenize{integral/methods:list-of-methods-and-highlight}}\begin{enumerate}
\item {} 
\sphinxquotedblleft{}BDF\sphinxquotedblright{}: for stiff differential equations.

\end{enumerate}


\section{Integration of ODE}
\label{\detokenize{integral/integrationODE::doc}}\label{\detokenize{integral/integrationODE:integration-of-ode}}

\subsection{Runge-Kutta}
\label{\detokenize{integral/integrationODE:runge-kutta}}

\subsection{Adaptive Stepsize for R-K}
\label{\detokenize{integral/integrationODE:adaptive-stepsize-for-r-k}}

\subsection{Modified Midpoint Method}
\label{\detokenize{integral/integrationODE:modified-midpoint-method}}\begin{equation*}
\begin{split}z_0 &= y(x) \\
z_1 &= z_0 + h f(x,z_0) \\
z_{m+1} &= z_{m-1} + 2h f(x+mh,z_m) \\
y(x+H) &\approx y_n = \frac{1}{2} \left( z_n + z_{n-1} + h f(x+H,z_n) \right) .\end{split}
\end{equation*}
This method contains only the even powers of \(h\) thus we can gain two orders of precision at a time by calculating one more correction.


\subsection{Refs \& Notes}
\label{\detokenize{integral/integrationODE:refs-notes}}

\chapter{Finite Element Method}
\label{\detokenize{finite-element-method/index::doc}}\label{\detokenize{finite-element-method/index:finite-element-method}}

\section{Differential Equations and Boundary Conditions}
\label{\detokenize{finite-element-method/pde-and-boundary-conditions::doc}}\label{\detokenize{finite-element-method/pde-and-boundary-conditions:differential-equations-and-boundary-conditions}}

\subsection{Two Types of Boundary Conditions}
\label{\detokenize{finite-element-method/pde-and-boundary-conditions:two-types-of-boundary-conditions}}
As an example, we have a partial differential equation
\begin{equation*}
\begin{split}\frac{d^2u}{dx^2} + f = 0,\end{split}
\end{equation*}
which describes a 1D problem.
\begin{itemize}
\item {} 
Dirichlet boundary condition: specify values for \(u\), such as \(u(0)=u_0\) and \(u(L)=u_L\);

\item {} 
Neumann boundary condition: specifiy values for \(u_{,x}\).

\end{itemize}

If we have only Neumann boundary condition, the solution is not unique. The example for it is tossing a bar, which can have both Neumann BC at both ends but it is moving.


\subsection{Example Problems}
\label{\detokenize{finite-element-method/pde-and-boundary-conditions:example-problems}}

\subsubsection{Elasticity Problem}
\label{\detokenize{finite-element-method/pde-and-boundary-conditions:elasticity-problem}}
We consider the displacement \(u(x)\) at each space coordinate \(x\) of a elastic bar under some external force. The strain is proportional to \(u_{,x}\). The equation would be
\begin{equation*}
\begin{split}-\frac{d\sigma}{dx} = f.\end{split}
\end{equation*}

\subsubsection{Heat Transfer}
\label{\detokenize{finite-element-method/pde-and-boundary-conditions:heat-transfer}}
Define temperature on a bar at each point \(u(x)\). Heat transfer is proportional to the head gradient, \(j= - \kappa u_{,x}\). The quation would be
\begin{equation*}
\begin{split}- \frac{dj}{dx} = f.\end{split}
\end{equation*}

\subsection{Strong Form and Weak Form of PDE}
\label{\detokenize{finite-element-method/pde-and-boundary-conditions:strong-form-and-weak-form-of-pde}}
Strong form of differential equations is basically the original form we write down. Strong form requires each term to be well defined at each point. However, we can derive a weak form that require each part to be well defined through the whole domain only, which is a relaxed requirement.


\section{Galerkin Method}
\label{\detokenize{finite-element-method/galerkin-method::doc}}\label{\detokenize{finite-element-method/galerkin-method:galerkin-method}}
Suppose we need to find the solution to equation
\begin{equation*}
\begin{split}\mathcal L_{x} \psi(x) = f(x).\end{split}
\end{equation*}
The key is that the solution can be approximated by
\begin{equation*}
\begin{split}\psi(x) = \sum_i u_i \phi_i(x),\end{split}
\end{equation*}
where \(\phi_i(x)\) are the basis functions.

\sphinxstylestrong{The purpose is to find the the coefficients} \(u_i\). Galerkin method has three steps.
\begin{enumerate}
\item {} 
discretize the space \(x\) and function space: triangulation,

\item {} 
discretize the function using weak form: assembly,

\item {} 
error estimation.

\end{enumerate}

Triangulation is basically setting up the basis function in a discretized space \(x\). One of the choice is the hat function.
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{plot-using-linear-combinations}.png}
\caption{Triangulation from \sphinxhref{https://www.comsol.com/multiphysics/finite-element-method}{comsol multiphysics}.}\label{\detokenize{finite-element-method/galerkin-method:id1}}\end{figure}

At each point \(x\), there is a hat function responsible for the approximation within \([x-\Delta x, x+\Delta x]\).

Those hat functions forms the basis for the approximated solution
\begin{equation*}
\begin{split}\psi = \sum_i u_i \phi_i.\end{split}
\end{equation*}
With this approximation, it requires the \sphinxstyleemphasis{test function} \(v\) to write down the weak form. Basically we multiply \(v\) on both sides of the equation then integrate by step. Then the differential equation can be rewrite into matrix form with basis \(\phi_i\),
\begin{equation*}
\begin{split}\mathbf K \mathbf U = \mathbf L.\end{split}
\end{equation*}
We solve the coefficients \(\mathbf U\) from the matrix equation.


\subsection{References and Notes}
\label{\detokenize{finite-element-method/galerkin-method:references-and-notes}}\begin{enumerate}
\item {} 
Freitag, K. J. (2007). Neural networks and differential equations.

\item {} 
\sphinxhref{https://www.comsol.com/multiphysics/finite-element-method}{COMSOL Multiphysics has a nice article}.

\end{enumerate}


\section{Collocation Method}
\label{\detokenize{finite-element-method/collocation-method::doc}}\label{\detokenize{finite-element-method/collocation-method:collocation-method}}
This method is named collocation method because it employs two sets of basis functions.

To be specific, the result function should be
\begin{equation*}
\begin{split}\psi = \psi(x_0) + \sum_i U_i H_i(x) + \sum_i U'_i S_i(x),\end{split}
\end{equation*}
where \(\psi(x_0)\) takes care of the boundary condition at \(x_0\).

With two set of basis functions the matrix form of the equation is double sized.


\subsection{References and Notes}
\label{\detokenize{finite-element-method/collocation-method:references-and-notes}}\begin{enumerate}
\item {} 
Freitag, K. J. (2007). Neural networks and differential equations.

\end{enumerate}


\chapter{Numerical Neutrino Osillations}
\label{\detokenize{neutrino-oscillations/index::doc}}\label{\detokenize{neutrino-oscillations/index:numerical-neutrino-osillations}}
In order to make sure the program we write works, we have to check the result of vacuum oscillations even oscillations in matter.


\section{Vacuum Oscillations}
\label{\detokenize{neutrino-oscillations/vacuum-oscillations::doc}}\label{\detokenize{neutrino-oscillations/vacuum-oscillations:vacuum-oscillations}}
\begin{sphinxadmonition}{note}{Choice of Unit}

For numericall purpose, we choose to scale distance x using \(\omega\).

Suppose we use MeV for energy scales, the distance \(\hat x = \omega x\) is related to actually distance \(x\) in km through
\begin{equation*}
\begin{split}x = \frac{\hat x}{\omega_v} = \frac{\hat x}{  1.90\times 10^{-4}  \mathrm{m}^{-1}  \frac{\delta m^2}{7.5\times 10^{-5}\mathrm{eV}^2} \frac{1\mathrm{MeV}}{E} } = \frac{\hat x}{0.190} \mathrm{km} \frac{7.5\times 10^{-5}\mathrm{eV}^2}{\delta m^2}  \frac{E}{1\mathrm{MeV}}.\end{split}
\end{equation*}\end{sphinxadmonition}

The numericall system is
\begin{equation*}
\begin{split}\frac{d\psi}{dx} = -i H \psi,\end{split}
\end{equation*}
where \(\psi\) is the wave function
\begin{equation*}
\begin{split}\psi = \begin{pmatrix}
\psi_0 \\
\psi_1
\end{pmatrix}\end{split}
\end{equation*}
and \(H\) is the vacuum Hamiltonian
\begin{equation*}
\begin{split}H = \frac{\omega}{2}\begin{pmatrix}
-\cos2\theta &\sin 2\theta \\
\sin 2\theta & \cos 2\theta
\end{pmatrix}.\end{split}
\end{equation*}
Initial condition is set to be
\begin{equation*}
\begin{split}\psi(0) = \begin{pmatrix}
1 \\
0
\end{pmatrix}.\end{split}
\end{equation*}
The theoretical prediction for survival probability of the first flavor is
\begin{equation*}
\begin{split}P  = 1 - \sin^2 2\theta \sin^2 ( \omega x/2 ).\end{split}
\end{equation*}

\section{Oscillations in Matter}
\label{\detokenize{neutrino-oscillations/matter-oscillations::doc}}\label{\detokenize{neutrino-oscillations/matter-oscillations:oscillations-in-matter}}

\subsection{Using numpy and scipy.ode}
\label{\detokenize{neutrino-oscillations/matter-oscillations:using-numpy-and-scipy-ode}}
\begin{sphinxVerbatim}[commandchars=\\\{\},numbers=left,firstnumber=1,stepnumber=1]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k+kn}{as} \PYG{n+nn}{np}
\PYG{k+kn}{from} \PYG{n+nn}{scipy.integrate} \PYG{k+kn}{import} \PYG{n}{odeint}
\PYG{k+kn}{from} \PYG{n+nn}{scipy.integrate} \PYG{k+kn}{import} \PYG{n}{ode}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib.pylab} \PYG{k+kn}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{csv}



\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Define parameters \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{n}{endpoint} \PYG{o}{=} \PYG{l+m+mi}{10000000}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} integration range}
\PYG{n}{dx} \PYG{o}{=} \PYG{l+m+mf}{1.0}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} step size}
\PYG{n}{lam0} \PYG{o}{=} \PYG{l+m+mf}{0.845258}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} in unit of omegam, omegam = 3.66619*10\PYGZca{}\PYGZhy{}17}
\PYG{n}{dellam} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mf}{0.00003588645221954444}\PYG{p}{,} \PYG{l+m+mf}{0.06486364865874367}\PYG{p}{]}\PYG{p}{)}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} deltalambda/omegam}
\PYG{n}{ks} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{p}{,}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{l+m+mi}{90}\PYG{p}{]}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} two k\PYGZsq{}s}
\PYG{n}{thm} \PYG{o}{=} \PYG{l+m+mf}{0.16212913985547778}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} theta\PYGZus{}m}

\PYG{n}{psi0}\PYG{p}{,} \PYG{n}{x0} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mf}{1.0}\PYG{o}{+}\PYG{l+m+mf}{0.j}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{o}{+}\PYG{l+m+mf}{0.j}\PYG{p}{]}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{c+c1}{\PYGZsh{} initial condition}
\PYG{n}{savestep} \PYG{o}{=} \PYG{l+m+mi}{100000}\PYG{p}{;} \PYG{c+c1}{\PYGZsh{} save to file every savestep steps}

\PYG{n}{xlin} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{arange}\PYG{p}{(}\PYG{n}{dx}\PYG{p}{,}\PYG{n}{endpoint}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{o}{*}\PYG{n}{dx}\PYG{p}{,} \PYG{n}{dx}\PYG{p}{)}

\PYG{n}{psi} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{xlin}\PYG{p}{)}  \PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{complex\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{xlinsave} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{xlin}\PYG{p}{)}\PYG{o}{/}\PYG{n}{savestep}\PYG{p}{)}\PYG{p}{;}
\PYG{n}{psisave} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{xlinsave}\PYG{p}{)}  \PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{n}{dtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{complex\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{probsave} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{zeros}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{xlinsave}\PYG{p}{)}  \PYG{p}{,} \PYG{l+m+mi}{3}\PYG{p}{]}\PYG{p}{)}



\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Define the functions required \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{k}{def} \PYG{n+nf}{hamiltonian}\PYG{p}{(}\PYG{n}{x}\PYG{p}{,} \PYG{n}{deltalambda}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{n}{thetam}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{return} \PYG{p}{[}\PYG{p}{[} \PYG{l+m+mi}{0}\PYG{p}{,}   \PYG{l+m+mf}{0.5}\PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{thetam}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{n}{deltalambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{deltalambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{l+m+mf}{1.0j} \PYG{o}{*} \PYG{p}{(} \PYG{o}{\PYGZhy{}} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{thetam}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(}  \PYG{p}{(} \PYG{n}{deltalambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{/}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{deltalambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{/}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{p}{)} \PYG{p}{)}  \PYG{p}{)} \PYG{p}{)}     \PYG{p}{]}\PYG{p}{,}   \PYG{p}{[} \PYG{l+m+mf}{0.5}\PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{thetam}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{n}{deltalambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{deltalambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{p}{)} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{exp}\PYG{p}{(} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0j} \PYG{o}{*} \PYG{p}{(} \PYG{o}{\PYGZhy{}} \PYG{n}{x} \PYG{o}{\PYGZhy{}} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{thetam}\PYG{p}{)} \PYG{o}{*} \PYG{p}{(} \PYG{n}{deltalambda}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{/}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{o}{+} \PYG{n}{deltalambda}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{/}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{k}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{x}\PYG{p}{)} \PYG{p}{)}  \PYG{p}{)} \PYG{p}{)}\PYG{p}{,} \PYG{l+m+mi}{0} \PYG{p}{]}\PYG{p}{]}   \PYG{c+c1}{\PYGZsh{} Hamiltonian for double frequency}

\PYG{k}{def} \PYG{n+nf}{deripsi}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{psi}\PYG{p}{,} \PYG{n}{deltalambda}\PYG{p}{,} \PYG{n}{k} \PYG{p}{,} \PYG{n}{thetam}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0j} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{dot}\PYG{p}{(} \PYG{n}{hamiltonian}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{deltalambda}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{thetam}\PYG{p}{)}\PYG{p}{,} \PYG{p}{[}\PYG{n}{psi}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{psi}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{]} \PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{jac}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{psi}\PYG{p}{,} \PYG{n}{deltalambda}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{n}{thetam}\PYG{p}{)}\PYG{p}{:}

    \PYG{k}{return} \PYG{o}{\PYGZhy{}}\PYG{l+m+mf}{1.0j} \PYG{o}{*} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{hamiltonian}\PYG{p}{(}\PYG{n}{t}\PYG{p}{,} \PYG{n}{deltalambda}\PYG{p}{,} \PYG{n}{k}\PYG{p}{,} \PYG{n}{thetam}\PYG{p}{)}\PYG{p}{)}




\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} integrate and save \PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}

\PYG{n}{sol} \PYG{o}{=} \PYG{n}{ode}\PYG{p}{(}\PYG{n}{deripsi}\PYG{p}{,}\PYG{n}{jac}\PYG{p}{)}\PYG{o}{.}\PYG{n}{set\PYGZus{}integrator}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{zvode}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{adams}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{atol}\PYG{o}{=}\PYG{l+m+mf}{1e\PYGZhy{}8}\PYG{p}{,} \PYG{n}{with\PYGZus{}jacobian}\PYG{o}{=}\PYG{n+nb+bp}{True}\PYG{p}{)}
\PYG{n}{sol}\PYG{o}{.}\PYG{n}{set\PYGZus{}initial\PYGZus{}value}\PYG{p}{(}\PYG{n}{psi0}\PYG{p}{,} \PYG{n}{x0}\PYG{p}{)}\PYG{o}{.}\PYG{n}{set\PYGZus{}f\PYGZus{}params}\PYG{p}{(}\PYG{n}{dellam}\PYG{p}{,}\PYG{n}{ks}\PYG{p}{,}\PYG{n}{thm}\PYG{p}{)}\PYG{o}{.}\PYG{n}{set\PYGZus{}jac\PYGZus{}params}\PYG{p}{(}\PYG{n}{dellam}\PYG{p}{,}\PYG{n}{ks}\PYG{p}{,}\PYG{n}{thm}\PYG{p}{)}

\PYG{n}{flag} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{flagsave} \PYG{o}{=} \PYG{l+m+mi}{0}


\PYG{k}{while} \PYG{n}{sol}\PYG{o}{.}\PYG{n}{successful}\PYG{p}{(}\PYG{p}{)} \PYG{o+ow}{and} \PYG{n}{sol}\PYG{o}{.}\PYG{n}{t} \PYG{o}{\PYGZlt{}} \PYG{n}{endpoint}\PYG{p}{:}
    \PYG{n}{sol}\PYG{o}{.}\PYG{n}{integrate}\PYG{p}{(}\PYG{n}{xlin}\PYG{p}{[}\PYG{n}{flag}\PYG{p}{]}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{np}\PYG{o}{.}\PYG{n}{mod}\PYG{p}{(}\PYG{n}{flag}\PYG{p}{,}\PYG{n}{savestep}\PYG{p}{)}\PYG{o}{==}\PYG{l+m+mi}{0}\PYG{p}{:}

        \PYG{n}{probsave}\PYG{p}{[}\PYG{n}{flagsave}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{t}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{]} \PYG{c+c1}{\PYGZsh{} save the probability}

        \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{assets/probtrans\PYGZhy{}test\PYGZhy{}1e7.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f\PYGZus{}handle}\PYG{p}{:}
            \PYG{n}{np}\PYG{o}{.}\PYG{n}{savetxt}\PYG{p}{(}\PYG{n}{f\PYGZus{}handle}\PYG{p}{,} \PYG{n}{probsave}\PYG{p}{[}\PYG{n}{flagsave}\PYG{p}{]}\PYG{p}{)}

        \PYG{n}{flagsave} \PYG{o}{=} \PYG{n}{flagsave} \PYG{o}{+} \PYG{l+m+mi}{1}

        \PYG{k}{print} \PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{o}{+} \PYG{n}{np}\PYG{o}{.}\PYG{n}{absolute}\PYG{p}{(}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{y}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2} \PYG{c+c1}{\PYGZsh{} Check if the solution conserves the total probability}
        \PYG{k}{print} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{n}{hamiltonian}\PYG{p}{(}\PYG{n}{sol}\PYG{o}{.}\PYG{n}{t}\PYG{p}{,}\PYG{n}{dellam}\PYG{p}{,}\PYG{n}{ks}\PYG{p}{,}\PYG{n}{thm}\PYG{p}{)}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} check if the Hamiltonian is Hermitian}

    \PYG{n}{flag} \PYG{o}{=} \PYG{n}{flag} \PYG{o}{+} \PYG{l+m+mi}{1}



\PYG{c+c1}{\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{} Notify at the end\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}\PYGZsh{}}
\PYG{k}{print} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{CONGRATS}\PYG{l+s+s2}{\PYGZdq{}}
\end{sphinxVerbatim}


\chapter{Artificial Neural Networks}
\label{\detokenize{artificial-neural-network/index::doc}}\label{\detokenize{artificial-neural-network/index:artificial-neural-networks}}

\section{Artificial Neural Networks Basics}
\label{\detokenize{artificial-neural-network/ann::doc}}\label{\detokenize{artificial-neural-network/ann:artificial-neural-networks-basics}}
Artificial neural networks works pretty well for equation solving.


\subsection{Universal Approximators}
\label{\detokenize{artificial-neural-network/ann:universal-approximators}}
Mawell Stinchcombe and Halber White proved that no theoretical constraints for the feedforward networks to approximate any measureable function. In principle one can use feedforward networks to approximate measurable functions to any accuracy.

However the convergence slows done if we have a lot of hidden units. There is a balance between accuracy and convergence rate. More hidden units means slow convergence but more accuracy.

Here is a quick review of the history of this topic.

\begin{sphinxadmonition}{note}{Kolmogorov's Theorem}

Kolmogorov's theorem shows that one can use finite number of carefully chosen continuous functions to exactly mix up by sums and multiplication with weights to a continuous multivariable fnction on a copact set.

\sphinxhref{http://neuron.eng.wayne.edu/tarek/MITbook/chap2/2\_3.html}{Here is the exact math.}
\end{sphinxadmonition}
\begin{enumerate}
\item {} 
Cybenko 1989

\end{enumerate}

Cybenko proved that
\begin{equation*}
\begin{split}\sum_k v_k \sigma(w_k x + u_k)\end{split}
\end{equation*}
is a good approximation of continuous functions because it is dense in continous function space. In this result, \(\sigma\) is a continuous sigmoidal function and the parameters are real.
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Hornik 1989

\end{enumerate}

\sphinxquotedblleft{}Single hidden layer feedforward networks can approximate any measurable functions arbitrarily well regardless of the activation function, the dimension of the input and the input space environment.\sphinxquotedblright{}
(\sphinxurl{http://deeplearning.cs.cmu.edu/notes/Sonia\_Hornik.pdf})

\begin{sphinxadmonition}{note}{Dense}

Set A is dense in set X means that we can use A to arbitarily approximate X. Mathematically for any given element in X, the neighbour of x always has nonzero intersection.
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Measurable Function}

Basically it means continuous.
\end{sphinxadmonition}


\subsubsection{Refs}
\label{\detokenize{artificial-neural-network/ann:refs}}\begin{enumerate}
\item {} 
Kolmogorov, A. N. (1957). \sphinxquotedblleft{}On the Representation of Continuous Functions of Several Variables by Superposition of Continuous Functions of one Variable and Addition,\sphinxquotedblright{} Doklady Akademii. Nauk USSR, 114, 679-681.

\item {} 
Maxwell Stinchcombe, Halbert White (1989). \sphinxhref{http://www.sciencedirect.com/science/article/pii/0893608089900208}{\sphinxquotedblleft{}Multilayer feedforward networks are universal approximators\sphinxquotedblright{}} . Neural Networks, Vol 2, 5, 359-366.

\end{enumerate}


\subsection{Activation Functions}
\label{\detokenize{artificial-neural-network/ann:activation-functions}}\begin{enumerate}
\item {} 
Uni-Polar Sigmoid Function

\end{enumerate}
\begin{equation*}
\begin{split}\frac{1}{1+e^{-x}}\end{split}
\end{equation*}\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{sigmoidFunction}.png}
\caption{Sigmoid function}\label{\detokenize{artificial-neural-network/ann:id3}}\end{figure}
\begin{enumerate}
\setcounter{enumi}{1}
\item {} 
Bipolar Sigmoid Function

\end{enumerate}
\begin{equation*}
\begin{split}\frac{1-e^{-x}}{1+e^{-x}}\end{split}
\end{equation*}\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{bipolarSigmoid}.png}
\caption{Bipolar Sigmoid}\label{\detokenize{artificial-neural-network/ann:id4}}\end{figure}
\begin{enumerate}
\setcounter{enumi}{2}
\item {} 
Hyperbolic Tangent

\end{enumerate}
\begin{equation*}
\begin{split}\tanh(x) = \frac{\sinh(x)}{\cosh(x)} = \frac{e^{x} - e^{-x}}{e^x + e^{-x}}\end{split}
\end{equation*}\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{tanh}.png}
\caption{Hyperbolic tangent}\label{\detokenize{artificial-neural-network/ann:id5}}\end{figure}
\begin{enumerate}
\setcounter{enumi}{3}
\item {} 
Radial Basis Function

\end{enumerate}
\begin{figure}[htbp]
\centering
\capstart

\noindent\sphinxincludegraphics{{unnormalized_radial_basis_functions.svg}.png}
\caption{Two unnormalized Gaussian radial basis functions in one input dimension. The basis function centers are located at x1=0.75 and x2=3.25. Source \sphinxhref{https://en.wikipedia.org/wiki/Radial\_basis\_function\#/media/File:Unnormalized\_radial\_basis\_functions.svg}{Unnormalized Radial Basis Functions}}\label{\detokenize{artificial-neural-network/ann:id6}}\end{figure}
\begin{enumerate}
\setcounter{enumi}{4}
\item {} 
Conic Section Function

\end{enumerate}


\subsubsection{Reffs}
\label{\detokenize{artificial-neural-network/ann:reffs}}\begin{enumerate}
\item {} 
\sphinxhref{http://www.cscjournals.org/manuscript/Journals/IJAE/volume1/Issue4/IJAE-26.pdf}{Performance Analysis of Various Activation Functions in Generalized MLP Architectures of Neural Networks}

\end{enumerate}


\subsection{Solving Differential Equations}
\label{\detokenize{artificial-neural-network/ann:solving-differential-equations}}
The problem here to solve is
\begin{equation*}
\begin{split}\frac{d}{dt}y(t)= - y(t),\end{split}
\end{equation*}
with initial condition \(y(0)=1\).

To construct a single layered neural network, the function is decomposed using
\begin{equation*}
\begin{split}y(t_i)& = y(t_0) + t_i v_k f(t_i w_k+u_k) \\
&= 1+t_i v_k f(t_i w_k+u_k) ,\end{split}
\end{equation*}
where \(y(t_0)\) is the initial condition and \(k\) is summed over.

\begin{sphinxadmonition}{note}{Articifial Neural Network}

THIS WILL BE NOTES FOR BASIC IDEAS OF ARTIFICIAL NEURAL NETWORK.
\end{sphinxadmonition}

Presumably this should be the gate controlling trigering of the neuron or not. Therefore the following expit function serves this purpose well,
\begin{equation*}
\begin{split}f(x) = \frac{1}{1+\exp(-x)}.\end{split}
\end{equation*}
One important reason for chosing this is that a lot of expressions can be calculated analytically and easily.

\begin{sphinxadmonition}{note}{Fermi-Dirac Distribution}

Aha, the Fermi-Dirac distribution.
\end{sphinxadmonition}

With the form of the function to be solved, we can define a cost
\begin{equation*}
\begin{split}I=\sum_i\left( \frac{dy}{dt}(t_i)+y(t_i) \right)^2,\end{split}
\end{equation*}
which should be minimized to 0 if our struture of networks is optimized for this problem.

Now the task becomes clear:
\begin{enumerate}
\item {} 
Write down the cost analytically;

\item {} 
Minimized cost to find structure;

\item {} 
Substitute back to the function and we are done.

\end{enumerate}


\subsection{Overfitting}
\label{\detokenize{artificial-neural-network/ann:overfitting}}
It is possible that we could over fit a network so that it works only for the training data. To avoid that, people use several strategies.
\begin{enumerate}
\item {} 
Split data into two parts, one for training and one for testing. \sphinxhref{https://www.youtube.com/watch?v=S4ZUwgesjS8}{A youtube video}

\item {} 
Throw more data in. At least 10 times as many as examples as the DoFs of the model.  \sphinxhref{https://www.youtube.com/watch?v=S4ZUwgesjS8}{A youtube video}

\item {} 
Regularization by plugin a artifical term to the cost function, as an example we could add the . \sphinxhref{https://www.youtube.com/watch?v=S4ZUwgesjS8}{A youtube video}

\end{enumerate}


\section{Neural Network and Finite Element Method}
\label{\detokenize{artificial-neural-network/neural-net-and-fem::doc}}\label{\detokenize{artificial-neural-network/neural-net-and-fem:neural-network-and-finite-element-method}}
We consider the solution to a differential equation
\begin{equation*}
\begin{split}\mathcal L \psi - f = 0.\end{split}
\end{equation*}
Neural network is quite similar to finite element method. In terms of finite element method, we can write down a neural network structured form of a function \phantomsection\label{\detokenize{artificial-neural-network/neural-net-and-fem:id1}}{\hyperref[\detokenize{artificial-neural-network/neural-net-and-fem:freitag2007}]{\sphinxcrossref{{[}Freitag2007{]}}}}
\begin{equation*}
\begin{split}\psi(x_i) = A(x_i) + F(x_i, \mathcal N_i),\end{split}
\end{equation*}
where \(\mathcal N\) is the neural network structure. Specifically,
\begin{equation*}
\begin{split}\mathcal N_i = \sigma( w_{ij} x_j + u_i ).\end{split}
\end{equation*}
The function is parameterized using the network. Such parameterization is similar to collocation method in finite element method, where multiple basis is used for each location.

One of the choice of the function \(F\) is a linear combination,
\begin{equation*}
\begin{split}F(x_i, \mathcal N_i) = x_i \mathcal N_i,\end{split}
\end{equation*}
and \(A(x_i)\) should take care of the boundary condition.

\begin{sphinxadmonition}{note}{Relation to finite element method}

This function is similar to the finite element function basis approximation. The goal in finite element method is to find the coefficients of each basis functions to achieve a good approximation. In ANN method, each sigmoid is the analogy to the basis functions, where we are looking for both the coefficients of sigmoids and the parameters of them. These sigmoid functions are some kind of adaptive basis functions.
\end{sphinxadmonition}

With such parameterization, the differential equation itself is parameterized such that
\begin{equation*}
\begin{split}\mathcal L \psi - f = 0,\end{split}
\end{equation*}
such that the minimization should be
\begin{equation*}
\begin{split}\lvert \mathcal L \psi - f \rvert^2 \to 0\end{split}
\end{equation*}
at each point.


\subsection{References and Notes}
\label{\detokenize{artificial-neural-network/neural-net-and-fem:references-and-notes}}

\chapter{Machine Learning}
\label{\detokenize{machine-learning/index::doc}}\label{\detokenize{machine-learning/index:machine-learning}}
Tensorflow is a nice package for deep learning.

Some resources:
\begin{enumerate}
\item {} 
\sphinxhref{https://www.youtube.com/watch?v=vq2nnJ4g6N0\&t=663s}{Tensorflow and deep learning - without a PhD by Martin Görner}.

\end{enumerate}


\chapter{Tech}
\label{\detokenize{tools/index::doc}}\label{\detokenize{tools/index:tech}}
Some useful technologies or techniques for computations.


\section{Git}
\label{\detokenize{tools/git::doc}}\label{\detokenize{tools/git:git}}

\subsection{Using Git (Only The Basics)}
\label{\detokenize{tools/git:using-git-only-the-basics}}
Thare are huge ammounts of git commands! What if I don't want to use any of these?
\begin{itemize}
\item {} 
\sphinxhref{https://desktop.github.com/}{GitHub Desktop}

\item {} 
\sphinxhref{https://www.gitkraken.com/}{GitKraken}

\item {} 
\sphinxhref{https://www.sourcetreeapp.com/}{SourceTree}

\end{itemize}


\subsubsection{Useful Commands}
\label{\detokenize{tools/git:useful-commands}}\begin{itemize}
\item {} 
To check all the commits related to a file, use \sphinxcode{git log -u}.

\item {} 
Try out \sphinxcode{git log -g} before determine which reflog to deal with.

\item {} 
To compare the changes with the last commit, use
\sphinxcode{git diff -{-}cached HEAD\textasciitilde{}1}.

\item {} 
A very useful article here: \sphinxhref{http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/}{Must Have Git Aliases: Advanced
Examples}.

\end{itemize}


\subsubsection{Useful Alias}
\label{\detokenize{tools/git:useful-alias}}\begin{itemize}
\item {} 
\sphinxcode{git config -{-}global alias.unstage 'reset HEAD -{-}'}

\item {} 
\sphinxcode{git config -{-}global alias.last 'log -1 HEAD'}

\end{itemize}

Among \sphinxcode{{[}alias{]}} section of \sphinxcode{\textasciitilde{}/.gitconfig} file:
\begin{itemize}
\item {} 
\sphinxcode{ll = log -{-}pretty=format:"\%C(yellow)\%h\%Cred\%d\textbackslash{}\textbackslash{} \%Creset\%s\%Cblue\textbackslash{}\textbackslash{} {[}\%cn{]}" -{-}decorate -{-}numstat}

\end{itemize}


\subsubsection{FAQ}
\label{\detokenize{tools/git:faq}}
P: \sphinxstylestrong{I am too lasy to type in {}`{}`git add .{}`{}`.}

S: The magic potion is \sphinxcode{git commit -a} which will do the staging and
commit at the same time.

P: \sphinxstylestrong{What has been changed since last stage?}

S: \sphinxcode{git diff} shows that.

P: \sphinxstylestrong{I typed in the wrong commit message.}

S: \sphinxcode{git commit -{-}amend} will allow you to change the commit message
you typed in before.

P: \sphinxstylestrong{I forgot to put add some files.}

S: Just add the file and use \sphinxcode{git commit -{-}amend}. This will allow you
to replace the previous commit.

P: \sphinxstylestrong{I accidentally added a file to staging.}

S: Should unstage the file. \sphinxcode{git reset HEAD filename.md} will do.

P: \sphinxstylestrong{I want to discard the changes I made since last commit.}

S: \sphinxstylestrong{This can be dangerous.} \sphinxcode{git checkout -{-} filename.md} can revert
averything back to the last commit. But it discards all the changes and
can not be recovered. DO NOT USE IT.

P: \sphinxstylestrong{I need to check what has changed in every commits.}

S: \sphinxcode{git log -{-}stat} will show the changed files.

P: \sphinxstylestrong{I want to create a new branch based on the current branch.}

S: \sphinxcode{git checkout -b newbranchname} is for you.

P: \sphinxstylestrong{I hate a branch called “wth” and want to delete it.}

S: \sphinxcode{git branch -d wth}.

P: \sphinxstylestrong{I want to change the name of a branch “wth” to “wtf”.}

S: \sphinxcode{git branch -m wth wtf} or checkout to the branch “wth” and use
\sphinxcode{git branch -m wtf}.

P: \sphinxstylestrong{Merge “goaway” branch to master branch.}

S: Checkout to master branch and \sphinxcode{git merge goaway}.

P: \sphinxstylestrong{Merge conflicts?}

S: Check the conflicts using \sphinxcode{git status}. Open up the conflict file
and you will see.

P: \sphinxstylestrong{So hard to resolve the conflicts.}

S: \sphinxcode{git mergetool} will use a graphical tool.


\subsection{Git Services}
\label{\detokenize{tools/git:git-services}}\begin{itemize}
\item {} 
GitHub

\item {} 
Bitbucket

\item {} 
GitLab

\end{itemize}


\subsection{Git on Server}
\label{\detokenize{tools/git:git-on-server}}

\subsubsection{A Very Basic Git Server}
\label{\detokenize{tools/git:a-very-basic-git-server}}
Since git is de-centralized, it would be nice to in fact create multiple \sphinxtitleref{backups} on different machines. A git server would do this perfectly. The bottom lines is you set up a git server and work everywhere even on a new computer.

How then?
\begin{enumerate}
\item {} 
\sphinxhref{https://git-scm.com/book/en/v2/Git-on-the-Server-Setting-Up-the-Server}{set up a git server}

\item {} 
Initialize a git repo \sphinxstylestrong{on server} so that you can push to.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cd} \PYG{o}{\PYGZlt{}}\PYG{n}{the} \PYG{n}{path} \PYG{n}{you} \PYG{n}{want} \PYG{n}{to} \PYG{n}{put} \PYG{n}{your} \PYG{n}{git} \PYG{n}{folder}\PYG{o}{\PYGZgt{}}
\PYG{n}{git} \PYG{n}{init} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{bare} \PYG{n}{yourreponame}\PYG{o}{.}\PYG{n}{git}
\end{sphinxVerbatim}

Then a folder named \sphinxcode{yourreponame.git} will be created under \sphinxcode{\textless{}the path you want to put your git folder\textgreater{}}.

\item {} 
One your local machine, using \sphinxcode{git clone ssh://\textless{}yourusername\textgreater{}@\textless{}your.server.name\textgreater{}/\textless{}path to repo\textgreater{}} will clone the empty repo to your local machine.

\end{enumerate}

Here I'll use my own machines as an example. After setting up the git server, I create initialized empty git repo on this server, under path \sphinxcode{/home/neutrino/gitserver/} (where neutrino is my user name on this ubuntu machine)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{init} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{bare} \PYG{n}{codebase}\PYG{o}{.}\PYG{n}{git}
\end{sphinxVerbatim}

Then I find this folder named \sphinxcode{codebase.git} under this path \sphinxcode{/home/neutrino/gitserver/}. The work on the server side is done now. This server has a name \sphinxcode{physicists.edu} (which I made up), on my local machine I clone it by

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{clone} \PYG{n}{ssh}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{neutrino}\PYG{n+nd}{@physicists}\PYG{o}{.}\PYG{n}{edu}\PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{neutrino}\PYG{o}{/}\PYG{n}{gitserver}\PYG{o}{/}\PYG{n}{codebase}\PYG{o}{.}\PYG{n}{git}
\end{sphinxVerbatim}

Whatever follows is to cd to this folder and start working on local machine then add, commit, and push.

\begin{sphinxadmonition}{note}{Push Existing Repos}

What if I already have a repo locally and need to push it to this new server? Use :code:{\color{red}\bfseries{}{}`}git remote add {\color{red}\bfseries{}{}`}. Here is an example.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{git} \PYG{n}{remote} \PYG{n}{add} \PYG{n}{newgitserver} \PYG{n}{ssh}\PYG{p}{:}\PYG{o}{/}\PYG{o}{/}\PYG{n}{neutrino}\PYG{n+nd}{@physicists}\PYG{o}{.}\PYG{n}{edu}\PYG{o}{/}\PYG{n}{home}\PYG{o}{/}\PYG{n}{neutrino}\PYG{o}{/}\PYG{n}{gitserver}\PYG{o}{/}\PYG{n}{codebase}\PYG{o}{.}\PYG{n}{git}
\end{sphinxVerbatim}

Change newgitserver to whatever you like. After that \sphinxcode{git push newgitserver} will push the codes to the new server.

Alternatively, you can change .git/config and name this new one the origin.
\end{sphinxadmonition}

References:
\begin{enumerate}
\item {} 
\sphinxhref{https://www.atlassian.com/git/tutorials/setting-up-a-repository/git-config}{Setting up a repository @ atlassian.com}

\end{enumerate}


\subsubsection{Using GitLab}
\label{\detokenize{tools/git:using-gitlab}}
Check out the \sphinxhref{https://about.gitlab.com/}{instructions}.


\section{Gnuplot}
\label{\detokenize{tools/gnuplot::doc}}\label{\detokenize{tools/gnuplot:gnuplot}}

\subsection{Examples}
\label{\detokenize{tools/gnuplot:examples}}
\begin{sphinxadmonition}{note}{Plot .csv data.}

Suppose we have data of such.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZhy{}0.00999983, 0.99995
\PYGZhy{}0.0199987, 0.9998
\PYGZhy{}0.0299955, 0.99955
\PYGZhy{}0.0399893, 0.9992
\PYGZhy{}0.0499792, 0.99875
\PYGZhy{}0.059964, 0.998201
\end{sphinxVerbatim}

To plot the second column against the first column, we use the using parameter in gnuplot.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
gnuplot \PYGZhy{}e \PYG{l+s+s2}{\PYGZdq{}set terminal png; set datafile separator \PYGZsq{},\PYGZsq{} ; plot \PYGZsq{}complex.txt\PYGZsq{} using 1:2\PYGZdq{}} \PYG{p}{\textbar{}} imgcat

\PYG{c+c1}{\PYGZsh{} datafile seperator is not always necessary}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\chapter{References}
\label{\detokenize{references/index::doc}}\label{\detokenize{references/index:references}}

\section{C++}
\label{\detokenize{references/index:c}}

\subsection{Books}
\label{\detokenize{references/index:books}}\begin{enumerate}
\item {} 
The C++ Programming Language

\item {} 
Programming Principles and Practice Using C++

\item {} 
The C++ Primer

\end{enumerate}


\subsection{Lectures}
\label{\detokenize{references/index:lectures}}\begin{enumerate}
\item {} 
\sphinxhref{https://www.youtube.com/watch?v=ki3B8a-jLrE}{C++ Beginners Tutorial 1 (For Absolute Beginners)}

\item {} 
\sphinxhref{https://www.youtube.com/watch?v=Rub-JsjMhWY}{C++ Programming}

\item {} 
\sphinxhref{https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-096-introduction-to-c-january-iap-2011/}{Introduction to C++}

\item {} 
\sphinxhref{https://www.coursera.org/learn/c-plus-plus-a}{Coursear Course: C++ For C Programmers, Part A}

\item {} 
\sphinxhref{https://www.udemy.com/courses/development/programming-languages/C-plus-plus-tutorials/}{Top C++ Courses and Tutorials}

\item {} 
\sphinxhref{https://www.sololearn.com/Course/CPlusPlus/}{On SoloLearn: C++ Tutorial}

\end{enumerate}


\subsection{Practice}
\label{\detokenize{references/index:practice}}
\sphinxhref{https://code.sololearn.com/\#cpp}{SoloLearn} provides \sphinxhref{https://code.sololearn.com/\#cpp}{this code playground} that we can use to test c++ codes.


\subsection{Libraries}
\label{\detokenize{references/index:libraries}}
For solving differential equations:
\begin{enumerate}
\item {} 
\sphinxurl{http://headmyshoulder.github.io/odeint-v2/}

\item {} 
\sphinxurl{http://www.mcs.anl.gov/petsc/}

\item {} 
\sphinxurl{https://github.com/trilinos/Trilinos}

\item {} 
\sphinxurl{http://homepage.math.uiowa.edu/~dstewart/meschach/meschach.html}

\item {} 
\sphinxurl{http://www.boost.org/}

\item {} 
\sphinxurl{http://www.feynarts.de/cuba/}

\item {} 
\sphinxurl{https://www.gnu.org/software/gsl/}

\end{enumerate}

Linear algebra
\begin{enumerate}
\item {} 
\sphinxurl{http://www.simunova.com/mtl4}

\end{enumerate}

Comparison of libs
\begin{enumerate}
\item {} 
Boost is faster than GSL in terms of random numbers and odeint. \sphinxhref{https://dilawarnotes.wordpress.com/2016/04/21/benchmark-ode-solver-gsl-vs-boost-odeint-library/}{Source}

\end{enumerate}


\section{Julia}
\label{\detokenize{references/index:julia}}

\subsection{Libraries}
\label{\detokenize{references/index:id1}}\begin{enumerate}
\item {} 
\sphinxurl{https://github.com/JuliaDiffEq/DifferentialEquations.jl}

\end{enumerate}


\section{Storage of Data}
\label{\detokenize{references/index:storage-of-data}}
tl;dr: Use HDF5
\begin{enumerate}
\item {} 
HDF5

\item {} 
\sphinxhref{http://bcolz.blosc.org/en/latest/}{BCOLZ} : not designed for multidimentional data.

\item {} 
\sphinxhref{https://github.com/alimanfoo/zarr}{Zarr} : works with multidimensional data and also parallel computating.

\item {} 
\sphinxhref{http://blaze.pydata.org/}{Blaze ecosystem}

\end{enumerate}

A article that compares HDF5, BCOLZ, and Zarr:\sphinxhref{http://alimanfoo.github.io/2016/04/14/to-hdf5-and-beyond.html}{To HDF5 and beyond}

I also recommend pandas. It is a python module that works very well with data. It even loads HDF5 out of box.


\chapter{Acknowledgement}
\label{\detokenize{acknowledgement::doc}}\label{\detokenize{acknowledgement:acknowledgement}}
I would like to thank my advisor Professor Huaiyu Duan for the support on my research. I would also like to thank Shashank Shalgar, Sajad Abbar for the many useful discussions and tutorials.

\begin{sphinxthebibliography}{NumericalRecipes}
\bibitem[NumericalRecipes]{\detokenize{NumericalRecipes}}{\phantomsection\label{\detokenize{finite-difference/pde/index:numericalrecipes}} 
Numerical Recipes in C
}
\bibitem[Freitag2007]{\detokenize{Freitag2007}}{\phantomsection\label{\detokenize{artificial-neural-network/neural-net-and-fem:freitag2007}} 
Freitag, K. J. (2007). Neural networks and differential equations.
}
\end{sphinxthebibliography}



\renewcommand{\indexname}{Index}
\printindex
\end{document}